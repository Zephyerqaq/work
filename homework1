#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct Node {
    int data;
    struct Node* next;
} Node;

// 定义链表结构
typedef struct {
    Node* head;
    int length;
} LinkedList;

bool initlist(LinkedList* list) {
    list->head = NULL;
    list->length = 0;
    return true;
}//链表初始化

bool insertelement(LinkedList* list, int i, int value) {
    if (i < 1)
        return false;
    Node* p = list->head;
    int j = 0;
    while (p != NULL && j < i - 1) {
        p = p->next;
        j++;
    }
    if (p == NULL)
        return false;
    Node* s = (Node*)malloc(sizeof(Node));
    s->data = value;
    s->next = p->next;
    p->next = s;
    return true;
}//按位插入

bool tailInsert(LinkedList* list, int value) {
    Node* s = (Node*)malloc(sizeof(Node));
    if (s == NULL)//是否初始化成功
        return false;
    s->data = value;
    s->next = NULL;
    if (list->head == NULL) {
        list->head = s;
    } else {
        Node* p = list->head;
        while (p->next != NULL) {
            p = p->next;
        }
        p->next = s;
    }
    return true;
}//尾插法

bool deleteNode(LinkedList* list, int i) {
    if (i < 1)
        return false;
    Node* p = list->head;
    int j = 0;
    while (p != NULL && j < i - 1) {
        p = p->next;
        j++;
    }
    if (p == NULL || p->next == NULL)
        return false;
    Node* temp = p->next;
    p->next = temp->next;
    free(temp);
    return true;
}//指定节点删除

void displayList(LinkedList* list) {
    Node* current = list->head;
    printf("LinkedList: ");
    while (current != NULL) {
        printf("%d->", current->data);
        current = current->next;
    }
}//遍历链表

int main() {
    LinkedList list;
    int choice, locate, num;
    initlist(&list);

    do {
        printf("===============\n");
        printf("[1] 初始化并插入元素\n");
        printf("[2] 选择位置插入\n");
        printf("[3] 删除指定元素\n");
        printf("[4] 遍历链表\n");
        printf("[5] 退出\n");
        printf("===============\n");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("节点数: ");
                scanf("%d", &num);
                printf("输入数据: ");
                for (int i = 0; i < num; i++) {
                    int value;
                    scanf("%d", &value);
                    tailInsert(&list, value);
                }
                break;
            case 2:
                printf("插入位置: ");
                scanf("%d %d", &locate, &num);
                if (!insertelement(&list, locate, num))
                    printf("插入失败 %d\n", locate);
                break;
            case 3:
                printf("选择删除位置: ");
                scanf("%d", &num);
                if (!deleteNode(&list, num))
                    printf("删除失败 %d\n", num);
                break;
            case 4:
                displayList(&list);
                break;
            case 5:
                printf("退出...\n");
                Node* current = list.head;
                Node* temp;
                while (current != NULL) {
                    temp = current;
                    current = current->next;
                    free(temp);
                }
                break;
            default:
                printf("无效输入.\n");
        }
    } while (choice != 5);

    return 0;
}
/////双链表
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
typedef struct Dnode{
    int data;
    struct Dnode* next;
    struct Dnode* prior;
}Dnode;
typedef struct {
    Dnode *head;
    Dnode *tail;
}Linkedlist;
bool initDlinklist(Linkedlist*list)
{
    list->head=NULL;
    list->tail=NULL;
    return  true;
}
bool insertnode(Linkedlist* list, int value) {
    Dnode* temp = (Dnode*) malloc(sizeof(Dnode));
    if (temp == NULL) {
        return false; // 内存分配失败
    }
    temp->data = value;
    temp->next = NULL;

    if (list->head == NULL) {
        // 如果链表为空，新节点既是头节点也是尾节点
        temp->prior = NULL;
        list->head = temp;
        list->tail = temp;
    } else {
        // 如果链表不为空，将新节点插入到尾部
        temp->prior = list->tail;
        list->tail->next = temp;
        list->tail = temp;
    }
    return true;
}
//bool insertnode(Dnode*pre,int value)
//{
//    Dnode* temp = (Dnode*) malloc(sizeof (Dnode));
//    if(temp == NULL)
//        return false;
//    temp->data = value;
//    temp->next=pre->next;
//    //pre->next->prior=temp;
//    if (pre->next != NULL) {
//        pre->next->prior = temp;
//    } else {
//        pre->next = temp;
//    }
//    temp->prior = pre;
//    return true;
//}//插入数据
void printList(Linkedlist* list) {
    Dnode* current = list->head;
    printf("DLinkedList: ");
    while (current != NULL) {
        printf("%d->", current->data);
        current = current->next;
    }
    printf("NULL\n");
}
bool deleteNode(Linkedlist* list, int i) {
    if (i < 1)
        return false;
    Dnode* p = list->head;
    int j = 0;
    while (p != NULL && j < i - 1) {
        p = p->next;
        j++;
    }
    if (p == NULL || p->next == NULL)
        return false;
    Dnode* temp = p->next;
    p->next = temp->next;
    free(temp);
    return true;
}//指定节点删除
int main() {
    Linkedlist list;
    int choice, num;
    initDlinklist(&list);

    do {
        printf("===============\n");
        printf("[1] chushihua\n");
        printf("[2] shanchuzhidingyuanshu\n");
        printf("[3] bianlilianbiao\n");
        printf("[4] tuichu\n");
        printf("===============\n");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("jiedianshu: ");
                scanf("%d", &num);
                printf("shurushuju: ");
                for (int i = 0; i < num; i++) {
                    int value;
                    scanf("%d", &value);
                    insertnode(&list, value);
                }
                break;

            case 2:
                printf("xuanzeshanchushuju: ");
                scanf("%d", &num);
                if (!deleteNode(&list, num))
                    printf("shanchushibai %d\n", num);
                break;
            case 3:
                printList(&list);
                break;
            case 4:
                printf("tuichu..\n");
                Dnode *current = list.head;
                Dnode *temp;
                while (current != NULL) {
                    temp = current;
                    current = current->next;
                    free(temp);
                }
                break;
            default:
                printf("wuxiaoshuchu.\n");
        }
    } while (choice != 4);

    return 0;
}
